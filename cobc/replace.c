/*
   Copyright (C) 2003-2022 Free Software Foundation, Inc.
   Written by Fabrice Le Fessant

   This file is part of GnuCOBOL.

   The GnuCOBOL compiler is free software: you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation, either version 3 of the
   License, or (at your option) any later version.

   GnuCOBOL is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GnuCOBOL.  If not, see <https://www.gnu.org/licenses/>.
*/

#include "tarstamp.h"
#include "config.h"

#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdarg.h>
#include <string.h>
#ifdef	HAVE_STRINGS_H
#include <strings.h>
#endif
#include <ctype.h>
#include <time.h>
#include <limits.h>


#include "cobc.h"
#include "tree.h"
#include "replace.h"

#define TRUE  1
#define FALSE 0

// #define DEBUG_REPLACE_TRACE
// #define DEBUG_REPLACE

#ifdef DEBUG_REPLACE_TRACE
#define DEBUG_REPLACE
#endif

/* This is an implementation of the *two* phases of COPY-REPLACING and
   REPLACE on a stream of token: the stream of tokens generated by the
   pplex.l/parser.y goes first through COPY-REPLACING replacements,
   and then through REPLACE replacements, as expected by the COBOL
   standard.

   However, it does fully conform to the standard, as REPLACE are
   parsed on the input stream *before* any COPY-REPLACING could have
   been applied.
 */


/* types */
enum cb_ppecho {
	CB_PPECHO_DIRECT  = 0, /* direct output */
	CB_PPECHO_REPLACE = 1, /* output to REPLACE */
};

struct cb_replacement_state {

	/* The list of tokens that are currently being checked for
	 * replacements. Empty, unless a partial match occurred. */
	/* not const */ struct cb_text_list *token_queue ;

	/* We don't queue WORD tokens immediately, because
	 * preprocessing could create larger words. Instead, we buffer
	 * WORD tokens (and merge them) until another kind of token
	 * (SPACE,DELIM,etc.) is received. */
	const char              *token_prequeue ;

	/* Current list of replacements specified in COPY-REPLACING or
	 * REPLACE */
	struct cb_replace_list  *replace_list ;

	/* List of replacements after a partial match that still need
	 * to be tested. */
	const struct cb_replace_list  *current_list ;

	/* The next pass to which generated tokens should be passed
	 * (either REPLACE pass or direct output */
	enum cb_ppecho           ppecho ;

#ifdef DEBUG_REPLACE
	const char* name ;
#endif
};


#ifdef DEBUG_REPLACE_TRACE

#define WITH_DEPTH int depth,
#define INIT_DEPTH 1,
#define MORE_DEPTH depth+1,

#define MAX_DEPTH 100
char depth_buffer[MAX_DEPTH+1];
#define DEPTH depth_buffer + ( MAX_DEPTH-depth )

#else // DEBUG_REPLACE_TRACE

#define WITH_DEPTH
#define DEPTH
#define INIT_DEPTH 
#define MORE_DEPTH

#endif // DEBUG_REPLACE_TRACE


#ifdef DEBUG_REPLACE

#define MAX_TEXT_LIST_STRING 10000
char text_list_string[MAX_TEXT_LIST_STRING];

static
char * string_of_list(const struct cb_text_list *list)
{
	int pos = 1;
	text_list_string[0] = '[';

	for(; list != NULL; list = list->next){
		int len = strlen(list->text);
		text_list_string[pos++] = '"'; 
		memcpy( text_list_string + pos, list->text, len );
		pos += len;
		text_list_string[pos++] = '"';
		text_list_string[pos++] = ',';
		text_list_string[pos++] = ' ';
	}

	text_list_string[pos] = ']';
	text_list_string[pos+1]=0;
	return text_list_string;
}
#endif // DEBUG_REPLACE

/* global state */
static struct cb_replacement_state * replace_repls;
static struct cb_replacement_state * copy_repls;

/* forward definitions */
static void ppecho_replace (WITH_DEPTH const char *token);
static void do_replace (WITH_DEPTH struct cb_replacement_state* repls);
static void check_replace_after_match (WITH_DEPTH struct cb_replacement_state *repls);
static void check_replace_all (WITH_DEPTH struct cb_replacement_state *repls,
			       const struct cb_text_list *new_text,
			       struct cb_text_list *tokens,
			       const struct cb_text_list *src,
			       const struct cb_replace_list *replace_list);

static COB_INLINE COB_A_INLINE int
is_space_or_nl (const char c)
{
	return c == ' ' || c == '\n';
}

/* This specific text_list_add function does a standard append on
   list, without expecting `last` field to be correctly set.  This is
   important as `pp_text_list_add` only correctly works when always
   adding on the same head, other `last` fields in the middle of the
   list not being correctly updated...
 */
static
struct cb_text_list *
text_list_add (WITH_DEPTH struct cb_text_list *list, const char *text)
{
#ifdef DEBUG_REPLACE_TRACE
	fprintf(stderr, "%stext_list_add(%s,'%s')\n",
		DEPTH, string_of_list(list), text);
#endif
	struct cb_text_list	*p;
	void			*tp;
	int size = strlen(text);

	tp = cobc_plex_malloc (size + 1);
	memcpy (tp, text, size);

	p = cobc_plex_malloc (sizeof (struct cb_text_list));
	p->text = tp;
	p->next = NULL;

	if (list==NULL) {
		return p;
	} else {
		struct cb_text_list *cursor = list;
		for(;cursor->next != NULL; cursor = cursor->next);
		cursor->next = p;
		return list;
	}
}


static
const char* pop_token (WITH_DEPTH struct cb_replacement_state *repls)
{
	const struct cb_text_list *q = repls->token_queue ;
	repls->token_queue = q->next ;
#ifdef DEBUG_REPLACE_TRACE
	fprintf(stderr, "%spop_token(%s) -> '%s'\n",
		DEPTH, repls->name, q->text);
#endif
	return q->text ;
}

static
void ppecho_switch (WITH_DEPTH struct cb_replacement_state *repls,
		    const char* token)
{
#ifdef DEBUG_REPLACE_TRACE
	fprintf(stderr, "%sppecho_switch(%s, '%s')\n",
		DEPTH, repls->name, token);
#endif
	switch( repls->ppecho ){
	case CB_PPECHO_DIRECT:
#ifdef DEBUG_REPLACE
		fprintf(stderr, "%s ppecho_direct('%s')\n", DEPTH, token);
#endif
		return ppecho_direct (token);
	case CB_PPECHO_REPLACE:
		return ppecho_replace (MORE_DEPTH token);
	}
}

static
void ppecho_switch_list (WITH_DEPTH struct cb_replacement_state *repls,
			 const struct cb_text_list *p)
{
#ifdef DEBUG_REPLACE_TRACE
	fprintf(stderr, "%sppecho_switch_list(%s, %s)\n",
		DEPTH, repls->name, string_of_list(p));
#endif

	for (;p;p=p->next){
		ppecho_switch (MORE_DEPTH repls, p->text);
	}
}

static
int is_leading_or_trailing (WITH_DEPTH int leading,
			    const char* src_token,
			    const char* token,
			    int strict)
{

	int src_len = strlen (src_token);
	int token_len = strlen(token);
	int result ;
	if( token_len > src_len || ( !strict && token_len == src_len ) ){
		int pos = leading ? 0 : token_len - src_len ;
		if( strncasecmp (src_token, token+pos, src_len) ){
			result = FALSE;
		} else {
			result = TRUE;
		}
	} else {
		result = FALSE;
	}
#ifdef DEBUG_REPLACE_TRACE
	fprintf(stderr,
		"%sis_leading_or_trailing(%d, '%s', input='%s', %d) -> %d\n",
		DEPTH, leading, src_token, token, strict, result);
#endif
	return result;
}

static
void ppecho_leading_or_trailing (WITH_DEPTH struct cb_replacement_state *repls,
				 int leading,
				 const char *src_token,
				 const char *token,
				 const struct cb_text_list *   new_text)
{
#ifdef DEBUG_REPLACE_TRACE
	fprintf(stderr,
		"%sppecho_leading_or_trailing(%s, %d, '%s', input='%s', ...)\n",
		DEPTH, repls->name, leading, src_token, token);
#endif

	int src_len = strlen (src_token);
	int token_len = strlen (token);

	if (!leading && token_len > src_len) {
		const char* remaining_token =
			cobc_plex_strsub (token,
					  token_len - src_len);
		ppecho_switch (MORE_DEPTH repls, remaining_token);
	}

	ppecho_switch_list (MORE_DEPTH repls, new_text);

	if (leading && token_len > src_len) {
		const char* remaining_token =
			cobc_plex_strsub (token+src_len,
					  token_len - src_len);
		ppecho_switch (MORE_DEPTH repls, remaining_token);
	}
}

static
void check_replace (WITH_DEPTH struct cb_replacement_state* repls,
		    const struct cb_replace_list *replace_list)
{
#ifdef DEBUG_REPLACE_TRACE
	fprintf(stderr, "%scheck_replace(%s, ...)\n", DEPTH,
		repls->name);
#endif
	repls->current_list = replace_list;

	if (replace_list == NULL){

		/* NO MATCH */
		const char* token = pop_token (MORE_DEPTH repls);
		ppecho_switch (MORE_DEPTH repls, token);
		check_replace_after_match (MORE_DEPTH repls);

	} else {
		const struct cb_replace_src *src = replace_list->src;
		const struct cb_text_list *new_text = replace_list->new_text;
		replace_list = replace_list->next;

		if (src->lead_trail == CB_REPLACE_LEADING
		    || src->lead_trail == CB_REPLACE_TRAILING){
			int leading = (src->lead_trail == CB_REPLACE_LEADING);
			unsigned int strict = src->strict;
			const char *src_token = src->text_list->text;
			const char *token = repls->token_queue->text;

			if (is_leading_or_trailing (MORE_DEPTH leading,
						    src_token,token,strict)){

				/* MATCH */
				ppecho_leading_or_trailing (MORE_DEPTH repls,
							    leading,
							    src_token,token,
							    new_text) ;
				pop_token (MORE_DEPTH repls);
				check_replace_after_match (MORE_DEPTH repls);
			} else {
				check_replace (MORE_DEPTH repls,replace_list);
			}
		} else {
			check_replace_all (MORE_DEPTH repls,new_text,
					   repls->token_queue,
					   src->text_list,
					   replace_list);
		}
	}
}

static
void check_replace_all (WITH_DEPTH struct cb_replacement_state *repls,
			const struct cb_text_list *new_text,
			struct cb_text_list *tokens,
			const struct cb_text_list *src,
			const struct cb_replace_list *replace_list)
{
#ifdef DEBUG_REPLACE_TRACE
	fprintf(stderr, "%scheck_replace_all(%s,",
		DEPTH, repls->name);
	fprintf(stderr, "%s    new_text = %s,\n", DEPTH,
		string_of_list(new_text));
	fprintf(stderr, "%s    tokens = %s,\n", DEPTH,
		string_of_list(tokens));
	fprintf(stderr, "%s    src = %s,\n", DEPTH,
		string_of_list(src));
	fprintf(stderr, "%s)\n", DEPTH);
#endif

	if (src==NULL){
		/* MATCH */
		ppecho_switch_list (MORE_DEPTH repls, new_text) ;
		repls->token_queue = tokens ;
		check_replace_after_match (MORE_DEPTH repls);
	} else {
		const char* src_token = src->text;
		if ( is_space_or_nl(src_token[0]) ){
			check_replace_all (MORE_DEPTH repls,new_text,tokens,
					   src->next, replace_list);
		} else {
			if (tokens == NULL){
				/* PARTIAL MATCH, wait for next token */
#ifdef DEBUG_REPLACE_TRACE
	fprintf(stderr, "%s  check_replace_all --> PARTIAL MATCH\n", DEPTH);
#endif
			} else {
				const char* token = tokens->text;
				tokens = tokens->next;
				if ( is_space_or_nl(token[0]) ){
					check_replace_all (MORE_DEPTH repls,
							   new_text,
							   tokens, src,
							   replace_list);
				} else {
					if (!strcasecmp(src_token,token)){

						check_replace_all(
							MORE_DEPTH repls,
							new_text,
							tokens,src->next,
							replace_list);
					} else {
						check_replace (
							MORE_DEPTH repls,
							replace_list);
					}
				}
			}
		}
	}
}

static
void check_replace_after_match (WITH_DEPTH struct cb_replacement_state *repls)
{
#ifdef DEBUG_REPLACE_TRACE
	fprintf(stderr, "%scheck_replace_after_match(%s)\n",
		DEPTH, repls->name);
#endif
  repls->current_list = NULL;
  if (repls->token_queue != NULL){
	  if( is_space_or_nl (repls->token_queue->text[0]) ){
		  ppecho_switch (MORE_DEPTH repls,
				 repls->token_queue->text);
		  repls->token_queue = repls->token_queue->next;
		  check_replace_after_match (MORE_DEPTH repls);
	  } else {
		  do_replace (MORE_DEPTH repls);
	  }
  }
}

static
void do_replace (WITH_DEPTH struct cb_replacement_state* repls)
{
#ifdef DEBUG_REPLACE_TRACE
	fprintf(stderr, "%sdo_replace(%s)\n",DEPTH, repls->name);
#endif
	if (repls->current_list == NULL){
		if (repls->replace_list == NULL){

			/* Beware: this is incorrect if a REPLACE is
			 * withing the queue, as it has already been
			 * parsed before any COPY-REPLACING
			 * substitution. */
			ppecho_switch_list (MORE_DEPTH repls,
					    repls->token_queue);
			repls->token_queue = NULL;
		} else {
			check_replace (MORE_DEPTH repls, repls->replace_list);
		}
	} else {
		check_replace (MORE_DEPTH repls, repls->current_list);
	}
}

/* Whether a word matches the definition of WORD in pplex.l */
static
int is_word (WITH_DEPTH const char* s){
	int i;
	int len = strlen (s);


	for( i = 0; i<len ; i++){
		char c = s[i];
		if( c == '_'
		    || c == '-'
		    || ( c >= '0' && c <= '9' )
		    || ( c >= 'A' && c <= 'Z' )
		    || ( c >= 'a' && c <= 'z' )
		    || ( c >= 128 && c <= 255 )
			){

		} else {
#ifdef DEBUG_REPLACE_TRACE
			fprintf(stderr, "%sis_word('%s') -> FALSE\n", DEPTH, s);
#endif
			return FALSE;
		}
	}
#ifdef DEBUG_REPLACE_TRACE
	fprintf(stderr, "%sis_word('%s') -> TRUE\n", DEPTH, s);
#endif
	return TRUE;
}

static void add_token_to_replace (WITH_DEPTH struct cb_replacement_state *repls,
				  int prequeue,
				  const char* token
	)
{
#ifdef DEBUG_REPLACE_TRACE
	fprintf(stderr, "%sadd_token_to_replace(%s%s, '%s')\n", DEPTH,
		repls->name, prequeue ? ", PREQUEUE" : "", token);
#endif
	if( prequeue ){

		if( is_word (MORE_DEPTH token) ) {

			if( repls->token_prequeue == NULL ){
				repls->token_prequeue =
					cobc_plex_strdup (token);
			} else {
				repls->token_prequeue =
					cobc_plex_stradd (repls->token_prequeue,
							  token);
			}
		} else {

			if( repls->token_prequeue == NULL ){
				add_token_to_replace(MORE_DEPTH repls, FALSE, token);
			} else {
				const char* pretoken = repls->token_prequeue;
				repls->token_prequeue = NULL;
				add_token_to_replace(MORE_DEPTH repls,
						     FALSE, pretoken);
				add_token_to_replace(MORE_DEPTH repls,
						     FALSE, token);
			}
		}
	}
	else {
		if( repls->token_queue == NULL &&
		    ( is_space_or_nl (token[0])) )  {
			ppecho_switch (MORE_DEPTH repls, token);
		} else {
#ifdef DEBUG_REPLACE_TRACE
			fprintf(stderr,
				"%s add_token_to_replace() -> push_token()\n",
				DEPTH);
#endif
			repls->token_queue =
				text_list_add(MORE_DEPTH repls->token_queue,
					      token);

			do_replace (MORE_DEPTH repls);
		}
	}
}

static
struct cb_replacement_state * create_replacements( enum cb_ppecho ppecho )
{
	struct cb_replacement_state * s;

	s = cobc_malloc (sizeof(struct cb_replacement_state));

	s->token_prequeue = NULL;
	s->token_queue = NULL;
	s->replace_list = NULL ;
        s->current_list = NULL ;
        s->ppecho = ppecho;

#ifdef DEBUG_REPLACE
	if( ppecho == CB_PPECHO_REPLACE ){
		s->name = "COPY-REPLACING";
	} else {
		s->name = "REPLACE";
	}
#endif

	return s;
}

static void reset_replacements( struct cb_replacement_state * s )
{
	s->token_prequeue = NULL;
	s->token_queue = NULL;
	s->replace_list = NULL ;
        s->current_list = NULL ;
}

static void ppecho_replace (WITH_DEPTH const char *token)
{
#ifdef DEBUG_REPLACE
	fprintf(stderr, "%sppecho_replace('%s')\n", DEPTH, token);
#endif
	add_token_to_replace(MORE_DEPTH replace_repls, TRUE, token);
}

void ppecho_copy (const char *token)
{
#ifdef DEBUG_REPLACE
	fprintf(stderr, "ppecho_copy('%s')\n", token);
#endif
	add_token_to_replace(INIT_DEPTH copy_repls, FALSE, token);
}

void init_replace( void )
{
#ifdef DEBUG_REPLACE_TRACE
	for(int i=0; i<MAX_DEPTH; i++) depth_buffer[i] = ' ';
	depth_buffer[MAX_DEPTH]=0;
#endif
	copy_repls = create_replacements (CB_PPECHO_REPLACE);
	replace_repls = create_replacements (CB_PPECHO_DIRECT);
}

void reset_replace( void )
{
	reset_replacements( copy_repls );
	reset_replacements( replace_repls );
}

void free_replace( void )
{
	reset_replace ();
	cobc_free (copy_repls);
	copy_repls = NULL;
	cobc_free (replace_repls);
	replace_repls = NULL;
}

struct cb_replace_list *get_copy_replacing_list (void)
{
	struct cb_replacement_state * repls = copy_repls ;
	if (repls == NULL) {
		init_replace();
		repls = replace_repls ;
	}
	return repls->replace_list ;
}

void set_copy_replacing_list (struct cb_replace_list *list)
{
	struct cb_replacement_state * repls = copy_repls ;

	repls->current_list = NULL;
	repls->replace_list = list ;
#ifdef DEBUG_REPLACE
	fprintf(stderr, "set_copy_replacing_list(\n");
	for(;list != NULL; list=list->next){
		fprintf(stderr, "    repl = {\n");
		fprintf(stderr, "       src = %s\n",
			string_of_list(list->src->text_list));
		fprintf(stderr, "       leading = %d\n",
			list->src->lead_trail);
		fprintf(stderr, "       new_text = %s\n",
			string_of_list(list->new_text));
		fprintf(stderr, "           };\n");
	}
	fprintf(stderr, "   )\n");
#endif
}

void
set_replace_list (struct cb_replace_list *list, const int is_pushpop)
{
#ifdef DEBUG_REPLACE_TRACE
	fprintf(stderr, "set_replace_list(...)\n");
#endif
	struct cb_replacement_state * repls = replace_repls ;
	/* Do not reset current candidates as the REPLACE is not yet active
	   repls->current_list = NULL;
	*/

	/* We changed the former behavior of GnuCOBOL, because the
	   `return` statements used to return from
	   `pp_set_replace_list` before calling
	   `set_print_replace_list`, whereas this function is not
	   always called. */
	if (!list) {
		/* REPLACE [LAST] OFF */
		if (!is_pushpop) {
			repls->replace_list = NULL;
			return;
		}
		if (!repls->replace_list) {
			return;
		}
		repls->replace_list = repls->replace_list->prev;
		return;
	}
	/* REPLACE [ALSO] ... */
	if (repls->replace_list && is_pushpop) {
		list->last->next = repls->replace_list;
		list->prev = repls->replace_list;
	} else {
		list->prev = NULL;
	}
	repls->replace_list = list;
}
